<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Amount
status: proposal
stage: 1
contributors: Ben Allen, Jesse Alama
location: https://github.com/tc39/proposal-amount/
</pre>

<emu-intro id="sec-decimal-intro-">
  <h1>Introduction</h1>
  <p>This specification consists of two parts:</p>
  <ul>
    <li>The specification of the <a href="https://github.com/tc39/proposal-amount/" title="Amount proposal (GitHub)">Amount proposal</a> and everything related to it, proposed to be added to ECMA-262 in new sections;</li>
    <li>A list of amendments to be made to ECMA-402.</li>
  </ul>
</emu-intro>

<emu-clause id="sec-the-amount-object">
  <h1>The Amount Object</h1>
  <emu-intro id="sec-amount-intro">
    <h1>Introduction</h1>
    <p>An Amount is an object that wraps a numeric value‚Äîas a Number, BigInt, or String‚Äîtogether with an optional unit (e.g., mile, kilogram, EUR, JPY, USD-per-mile). One can intuitively understand an Amount as a value that, so to speak, knows what it is measuring.</p>
    <p>When precision options (such as fractionDigits or significantDigits) are applied, or when unit conversion is performed, the numeric value is stored as a <dfn id="dfn-decimal-digit-string">decimal digit string</dfn>, which is a String in StrDecimalLiteral form. Otherwise, the original JavaScript value type (Number, BigInt, or String) is retained.</p>
    <p>Rounding a mathematical value is an important part of this spec. When we say <dfn id="dfn-amount-rounding-mode">rounding mode</dfn> in this specification we simply refer to <emu-xref href="#table-intl-rounding-modes">ECMA-402's definition</emu-xref>.</p>
  </emu-intro>

  <emu-clause id="sec-amount-abstract-operations">
    <h1>Abstract Operations</h1>

    <emu-clause id="sec-operations-for-reading-options">
      <h1>Operations for Reading Options</h1>

      <!-- Copied and modified from ECMA-402 GetOption -->
      <!-- The difference: -->
      <!-- Added support for ~number~ as an expected data type -->

      <emu-clause id="sec-getoption" type="abstract operation">
        <h1>
          GetOption (
            _options_: an Object,
            _property_: a property key,
            _type_: ~boolean~, ~string~ or ~number~,
            _values_: ~empty~ or a List of ECMAScript language values,
            _default_: ~required~ or an ECMAScript language value,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It extracts the value of the specified property of _options_, converts it to the required _type_, checks whether it is allowed by _values_ if _values_ is not ~empty~, and substitutes _default_ if the value is *undefined*.</dd>
        </dl>
        <emu-alg>
          1. Let _value_ be ? Get(_options_, _property_).
          1. If _value_ is *undefined*, then
            1. If _default_ is ~required~, throw a *RangeError* exception.
            1. Return _default_.
          1. If _type_ is ~boolean~, then
            1. Set _value_ to ToBoolean(_value_).
          1. Else if _type_ is ~number~, then
            1. Set _value_ to ? ToNumber(_value_).
          1. Else,
            1. Assert: _type_ is ~string~.
            1. Set _value_ to ? ToString(_value_).
          1. If _values_ is not ~empty~ and _values_ does not contain _value_, throw a *RangeError* exception.
          1. Return _value_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <!-- This is copied directly from proposal-intl-keep-trailing-zeros -->
    <!-- See http://tc39.es/proposal-intl-keep-trailing-zeros/ -->
    <emu-clause id="sec-runtime-semantics-stringintlmv" type="sdo" number="15">
      <h1>Runtime Semantics: StringIntlMV</h1>
      <dl class="header">
      </dl>
      <emu-note>
        <del class="block">
        <p>The
 conversion of a |StringNumericLiteral| to a Number value is similar overall to the determination of the NumericValue of a |NumericLiteral| (see <emu-xref href="#sec-literals-numeric-literals"></emu-xref>), but some of the details are different.</p>
        </del>
        <ins class="block">
        <p>
          The conversion of a |StringNumericLiteral| to a mathematical value and a precision is similar overall to the determination of the NumericValue of a |NumericLiteral| (see <emu-xref href="#sec-literals-numeric-literals"></emu-xref>), but some of the details are different.
          The result of StringIntlMV is a List value with two elements, a mathematical value and the count of decimal digits in the source text.
        </p>
        </ins>
      </emu-note>
      <emu-grammar>StringNumericLiteral ::: StrWhiteSpace?</emu-grammar>
      <emu-alg>
        1. Return <del>0</del><ins>¬´ 0, 0 ¬ª</ins>.
      </emu-alg>
      <emu-grammar>StringNumericLiteral ::: StrWhiteSpace? StrNumericLiteral StrWhiteSpace?</emu-grammar>
      <emu-alg>
        1. Return StringIntlMV of |StrNumericLiteral|.
      </emu-alg>
      <emu-grammar>StrNumericLiteral ::: NonDecimalIntegerLiteral</emu-grammar>
      <emu-alg>
        1. <del>Return MV of |NonDecimalIntegerLiteral|.</del>
        1. <ins>Let _i_ be MV of |NonDecimalIntegerLiteral|.</ins>
        1. <ins>Return ¬´ _i_, 0 ¬ª.</ins>
      </emu-alg>
      <emu-grammar>StrDecimalLiteral ::: `-` StrUnsignedDecimalLiteral</emu-grammar>
      <emu-alg>
        1. Let <del>_a_</del><ins>_x_</ins> be StringIntlMV of |StrUnsignedDecimalLiteral|.
        1. <ins>Let _a_ be the first element of _x_.</ins>
        1. <ins>Let _n_ be the second element of _x_.</ins>
        1. If _a_ is 0, return <del>~negative-zero~</del><ins>¬´ ~negative-zero~, _n_ ¬ª</ins>.
        1. If _a_ is ~positive-infinity~, return <del>~negative-infinity~</del><ins>¬´ ~negative-infinity~, 0 ¬ª</ins>.
        1. Return <del>-_a_</del><ins>¬´ -_a_, _n_ ¬ª</ins>.
      </emu-alg>
      <emu-grammar>StrUnsignedDecimalLiteral ::: `Infinity`</emu-grammar>
      <emu-alg>
        1. Return <del>~positive-infinity~</del><ins>¬´ ~positive-infinity~, 0 ¬ª</ins>.
      </emu-alg>
      <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits `.` DecimalDigits? ExponentPart?</emu-grammar>
      <emu-alg>
        1. Let _a_ be MV of the first |DecimalDigits|.
        1. <ins>Let _m_ be the number of code points in the first |DecimalDigits|.</ins>
        1. If the second |DecimalDigits| is present, then
          1. Let _b_ be MV of the second |DecimalDigits|.
          1. Let _n_ be the number of code points in the second |DecimalDigits|.
        1. Else,
          1. Let _b_ be 0.
          1. Let _n_ be 0.
        1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.
        1. Return <ins>¬´</ins> (_a_ + (_b_ √ó 10<sup>-_n_</sup>)) √ó 10<sup>_e_</sup><ins>, _m_ + _n_ ¬ª</ins>.
      </emu-alg>
      <emu-grammar>StrUnsignedDecimalLiteral ::: `.` DecimalDigits ExponentPart?</emu-grammar>
      <emu-alg>
        1. Let _b_ be MV of |DecimalDigits|.
        1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.
        1. Let _n_ be the number of code points in |DecimalDigits|.
        1. Return <ins>¬´</ins> _b_ √ó 10<sup>_e_ - _n_</sup><ins>, _n_ ¬ª.</ins>
      </emu-alg>
      <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPart?</emu-grammar>
      <emu-alg>
        1. Let _a_ be MV of |DecimalDigits|.
        1. <ins>Let _m_ be the number of code points in |DecimalDigits|.</ins>
        1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.
        1. Return <ins>¬´</ins> _a_ √ó 10<sup>_e_</sup><ins>, _m_ ¬ª</ins>.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-countfractiondigits" type="sdo">
      <h1>Runtime Semantics: CountFractionDigits</h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>It computes the power of 10 of the least significant precise digit of a |StringNumericLiteral|.</p>
      </emu-note>
      <emu-grammar>StringNumericLiteral ::: StrWhiteSpace?</emu-grammar>
      <emu-alg>
        1. Return 0.
      </emu-alg>
      <emu-grammar>StringNumericLiteral ::: StrWhiteSpace? StrNumericLiteral StrWhiteSpace?</emu-grammar>
      <emu-alg>
        1. Return CountFractionDigits of |StrNumericLiteral|.
      </emu-alg>
      <emu-grammar>StrNumericLiteral ::: NonDecimalIntegerLiteral</emu-grammar>
      <emu-alg>
        1. Return 0.
      </emu-alg>
      <emu-grammar>StrUnsignedDecimalLiteral ::: `Infinity`</emu-grammar>
      <emu-alg>
        1. Return 0.
      </emu-alg>
      <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits `.` DecimalDigits? ExponentPart?</emu-grammar>
      <emu-alg>
        1. If |ExponentPart| is present, let _e_ be the MV of |ExponentPart|, else let _e_ be 0.
        1. If the second |DecimalDigits| is present, let _m_ be the number of code points in the second |DecimalDigits|, else let _m_ be 0.
        1. Return _m_ - _e_.
      </emu-alg>
      <emu-grammar>StrUnsignedDecimalLiteral ::: `.` DecimalDigits ExponentPart?</emu-grammar>
      <emu-alg>
        1. Let _m_ be the number of code points in |DecimalDigits|.
        1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.
        1. Return _m_ - _e_.
      </emu-alg>
      <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPart?</emu-grammar>
      <emu-alg>
        1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.
        1. Return -_e_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-amount-abstract-ops-mv">
      <h1>Abstract Operations</h1>

      <emu-clause id="sec-amount-applyroundingmodetopositive" type="abstract operation">
        <h1>ApplyRoundingModeToPositive(
          _m_: a positive mathematical value,
          _roundingMode_: a rounding mode
        ): an integer
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It computes the closest integer approximation to a given positive mathematical value, rounded according to the given rounding mode.</dd>
        </dl>
        <emu-alg>
          1. Let _mLow_ be floor(_m_).
          1. Let _fraction_ be _m_ ‚Äì _mLow_.
          1. If _fraction_ = 0, return _mLow_.
          1. Let _mHigh_ be _mLow_ + 1.
          1. If _roundingMode_ is *"floor"* or *"trunc"*, return _mLow_.
          1. If _roundingMode_ is *"ceil" or *"expand"*, return _mHigh_.
          1. If _fraction_ < 0.5, return _mLow_.
          1. If _fraction_ > 0.5, return _mHigh_.
          1. If _roundingMode_ is *"halfTrunc"* or *"halfFloor"*, return _mLow_.
          1. If _roundingMode_ is *"halfExpand"* or *"halfCeil"*, return _mHigh_.
          1. If _mLow_ is even, return _mLow_.
          1. Return _mHigh_.
        </emu-alg>
      </emu-clause>

    <emu-clause id="sec-amount-reverseroundingmode" type="abstract operation">
      <h1>ReverseRoundingMode (
        _mode_: a rounding mode
      ): a rounding mode
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the rounding mode that would be used if we were to rounding a negative mathematical value with the given rounding mode.</dd>
      </dl>
      <emu-alg>
        1. If _mode_ is *"floor"*, return *"ceil"*.
        1. If _mode_ is *"ceil"*, return *"floor"*.
        1. If _mode_ is *"halfCeil"*, return *"halfFloor"*.
        1. If _mode_ is *"halfFloor"*, return *"halfCeil"*.
        1. Otherwise, return _mode_.
      </emu-alg>
     </emu-clause>

      <emu-clause id="sec-amount-roundtofractiondigits" type="abstract operation">
        <h1>RoundAmountValueToFractionDigits(
          _v_: a mathematical value,
          _n_: an integer,
          optional _roundingMode_: a rounding mode
        ): a mathematical value
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It computes the closest approximation to a given mathematical value that has at most the given number of fractional digits, rounding (if necessary) according to the given rounding mode.</dd>
        </dl>
        <emu-alg>
          1. If _v_ = 0, return 0.
          1. If _roundingMode_ is *undefined*, set _roundingMode_ to *"halfEven"*.
          1. If v &lt; 0, then
            1. Let _reverseRoundingMode_ be _roundingMode_.
            1. If _roundingMode_ is *"floor"*, set _reverseRoundingMode_ to *"ceil"*.
            1. If _roundingMode_ is *"ceil"*, set _reverseRoundingMode_ to *"floor"*.
            1. If _roundingMode_ is *"halfCeil"*, set _reverseRoundingMode_ to *"halfFloor"*.
            1. If _roundingMode_ is *"halfFloor"*, set _reverseRoundingMode_ to *"halfCeil"*.
            1. Let _d_ be RoundAmountValueToFractionDigits(‚Äì_v_, _n_, _reverseRoundingMode_).
            1. Return ‚Äì_d_.
          1. Let _m_ be _v_ √ó 10<sup>_n_</sup>.
          1. Let _rounded_ be ApplyRoundingModeToPositive(_m_, _roundingMode_).
          1. Return _rounded_ √ó 10<sup>-_n_</sup>.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-amount-rendermvwithfractiondigits" type="abstract operation">
        <h1>RenderAmountValueWithFractionDigits (
          _v_: an Intl mathematical value,
          _numDigits_: an integer,
          optional _roundingMode_: a rounding mode
        ): a String
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It renders the given Intl mathematical value with a given number of fractional digits, rounding, if necessary, using the given rounding mode, which, if missing, is *"halfEven"*.</dd>
        </dl>
        <emu-alg>
          1. If _v_ is ~not-a-number~, return *"NaN"*.
          1. If _v_ is ~negative-infinity~, return *"-Infinity"*.
          1. If _v_ is ~positive-infinity~, return *"Infinity"*.
          1. If _v_ is ~minus-zero~, then
            1. If _numDigits_ < 0, then
              1. Let _exp_ be the unique string representation of -_numDigits_ in base 10 without duplicate leading zeros.
              1. Return the string-concatenation of *"0"*, *"e"*, and _exp_.
            1. Otherwise:
              1. Let _trailingZeroes_ be *"0"* repeated _numDigits_ times.
              1. Let _z_ be *"-0"*.
              1. If _numDigits_ = 0, return _z_.
              1. Otherwise, return the string-concatenation of _z_, *"."* and _trailingZeroes_.
          1. If _roundingMode_ is *undefined*, set _roundingMode_ to *"halfEven"*.
          1. If _v_ < 0, let _prefix_ be *"-"*, else let _prefix_ be "".
          1. If _v_ < 0, then
            1. Set _v_ to -_v_.
            1. Set _roundingMode_ to ReverseRoundingMode(_roundingMode_).
          1. Let _rounded_ be ApplyRoundingModeToPositive(_v_ √ó 10<sup>_numDigits_</sup>, _roundingMode_).
          1. Let _e_ be the smallest non-negative integer such that _rounded_ √ó 10<sup>-_numDigits_</sup> is an integer.
          1. Let _s_ be the unique decimal string representation of _rounded_ without duplicate leading zeroes.
          1. If _numDigits_ > _e_, then
            1. If _v_ is an integer, return the string-concatenation of _prefix, _s_, *"."*, and *"0"* repeated _numDigits_ times.
            1. Otherwise, return the string-concatenation of _prefix_, _s_ and *"0"* repeated _numDigits_ - _e_ times.
          1. If 0 < _numDigits_, then
            1. Return the string-concatenation of _prefix, _s_ and *"0"* repeated _e_ - _numDigits_ times.
          1. Otherwise:
            1. Assert: _rounded_ is an integer.
            1. Let _firstDigit_ be the substring of _s_ from 0 to 1.
            1. Let _p_ be the unique integer such that 1 ‚â§ _rounded_ √ó 10<sup>_p_</sup> < 10.
            1. Let _n_ be _p_ + _numDigits_.
            1. Assert: _n_ ‚â• 0.
            1. Let _exp_ be the unique string representation of _n_ in base-10 without duplicate leading zeros.
            1. If _n_ = 0, then
              1. Return the string-concatenation of _s_, *"e"*, and _exp_.
            1. Otherwise:
              1. Let _remainingDigits_ be the substring of _s_ from 1 to _n_.
              1. Return the string-concatenation of _firstDigit_, *"."*, _remainingDigits_, *"e"*, and _exp_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-amount-SignificantToFractionDigits" type="abstract operation">
        <h1>SignificantToFractionDigits (
          _value_: an Intl mathematical value,
          _significantDigits_: a positive integer
        ): an integer
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. If _value_ is one of ~not-a-number~, ~positive-infinity~, or ~negative-infinity~, then
            1. Return 0.
          1. If _value_ is one of 0 or ~negative-zero~, then
            1. Let _integerDigits_ be 1.
          1. Else,
            1. Let _integerDigits_ be the smallest integer such that 10<sup>_integerDigits_</sup> > abs(_value_).
          1. Assert: _significantDigits_ > 0.
          1. Return _significantDigits_ - _integerDigits_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-amount-getamountoptions" type="abstract operation">
        <h1>GetAmountOptions (
          _opts_: an Object
        ): either a normal completion containing a Record with fields [[FractionDigits]] (a non-negative integer or *undefined*), [[RoundingMode]] (a <emu-xref href="#dfn-amount-rounding-mode">rounding mode</emu-xref>), [[SignificantDigits]] (a positive integer or *undefined*), and [[Unit]] (a String or *undefined*) or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It validates the given _options_ (an ECMAScript object) for creating an Amount and returns a Record with slots set to appropriate marthematical values (or *undefined*).</dd>
        </dl>
        <emu-alg>
          1. Let _opts_ be ? GetOptionsObject(_opts_).
          1. Let _fractionDigits_ be ? GetOption(_opts_, *"fractionDigits"*, ~number~, ~empty~, *undefined*).
          1. Let _roundingMode_ be ? GetOption(_opts_, *"roundingMode"*, ~string~, ¬´ *"ceil"*, *"floor"*, *"expand"*, *"trunc"*, *"halfCeil"*, *"halfFloor"*, *"halfExpand"*, *"halfTrunc"*, *"halfEven"* ¬ª, *"halfEven"*).
          1. Let _significantDigits_ be ? GetOption(_opts_, *"significantDigits"*, ~number~, ~empty~, *undefined*).
          1. Let _unit_ be ? GetOption(_opts_, *"unit"*, ~string~, ~empty~, *undefined*).
          1. If _fractionDigits_ is not *undefined*, then
            1. If _significantDigits_ is not *undefined*, throw a *RangeError* exception.
            1. If _fractionDigits_ is not an integral number, throw a *RangeError* exception.
          1. Else if _significantDigits_ is not *undefined*, then
            1. If _significantDigits_ is not an integral number, throw a *RangeError* exception.
            1. If ‚Ñù(_significantDigits_) < 1, throw a *RangeError* exception.
          1. If _unit_ is the empty String, throw a *RangeError* exception.
          1. Return the Record { [[FractionDigits]]: _fractionDigits_, [[RoundingMode]]: _roundingMode_, [[SignificantDigits]]: _significantDigits_, [[Unit]]: _unit_ }.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-amount-getunitconversionfactor" type="abstract operation">
        <h1>GetUnitConversionFactor (
          _unit_: a String
        ): either a normal completion containing a Record with fields [[Category]] (a String), [[Factor]] (a Number), and [[Offset]] (a Number) or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns the conversion data for converting _unit_ to its base unit within its unit category.</dd>
        </dl>
        <emu-alg>
          1. If _unit_ is not recognized as a unit for which conversion data is available, throw a *RangeError* exception.
          1. Return an implementation-defined Record { [[Category]], [[Factor]], [[Offset]] } where [[Category]] is a String identifying the unit category of _unit_ (e.g., *"length"*, *"mass"*, *"temperature"*), [[Factor]] is a Number representing the multiplication factor for converting from _unit_ to the base unit of its category, and [[Offset]] is a Number representing the additive offset for converting from _unit_ to the base unit (*+0*<sub>ùîΩ</sub> for most units; non-zero for temperature units such as *"fahrenheit"*).
        </emu-alg>
        <emu-note>
          <p>Implementations should provide conversion data consistent with the Unicode Common Locale Data Repository (CLDR) <code>units.xml</code> supplemental data. The formula for converting a value in _unit_ to its base unit is: <i>baseValue</i> = <i>value</i> √ó [[Factor]] + [[Offset]].</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-amount-convertunitvalue" type="abstract operation">
        <h1>ConvertUnitValue (
          _value_: a Number,
          _sourceUnit_: a String,
          _targetUnit_: a String
        ): either a normal completion containing a Number or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It converts _value_ from _sourceUnit_ to _targetUnit_ using Number arithmetic.</dd>
        </dl>
        <emu-alg>
          1. Let _sourceConv_ be ? GetUnitConversionFactor(_sourceUnit_).
          1. Let _targetConv_ be ? GetUnitConversionFactor(_targetUnit_).
          1. If SameValue(_sourceConv_.[[Category]], _targetConv_.[[Category]]) is *false*, throw a *RangeError* exception.
          1. Let _sourceFactor_ be _sourceConv_.[[Factor]].
          1. Let _sourceOffset_ be _sourceConv_.[[Offset]].
          1. Let _targetFactor_ be _targetConv_.[[Factor]].
          1. Let _targetOffset_ be _targetConv_.[[Offset]].
          1. Let _baseValue_ be Number::add(Number::multiply(_value_, _sourceFactor_), _sourceOffset_).
          1. Let _result_ be Number::divide(Number::subtract(_baseValue_, _targetOffset_), _targetFactor_).
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-amount-getconverttodigitoptions" type="abstract operation">
        <h1>GetConvertToDigitOptions (
          _options_: an Object
        ): either a normal completion containing a Record with fields [[MinimumFractionDigits]] (a Number or *undefined*), [[MaximumFractionDigits]] (a Number or *undefined*), [[MinimumSignificantDigits]] (a Number or *undefined*), [[MaximumSignificantDigits]] (a Number or *undefined*), [[RoundingMode]] (a String), and [[RoundingPriority]] (a String) or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It reads digit options from _options_ and returns a Record. If no digit options are specified, defaults of minimumFractionDigits 0 and maximumFractionDigits 3 are used.</dd>
        </dl>
        <emu-alg>
          1. Let _mnfd_ be ? GetOption(_options_, *"minimumFractionDigits"*, ~number~, ~empty~, *undefined*).
          1. Let _mxfd_ be ? GetOption(_options_, *"maximumFractionDigits"*, ~number~, ~empty~, *undefined*).
          1. Let _mnsd_ be ? GetOption(_options_, *"minimumSignificantDigits"*, ~number~, ~empty~, *undefined*).
          1. Let _mxsd_ be ? GetOption(_options_, *"maximumSignificantDigits"*, ~number~, ~empty~, *undefined*).
          1. Let _roundingMode_ be ? GetOption(_options_, *"roundingMode"*, ~string~, ¬´ *"ceil"*, *"floor"*, *"expand"*, *"trunc"*, *"halfCeil"*, *"halfFloor"*, *"halfExpand"*, *"halfTrunc"*, *"halfEven"* ¬ª, *"halfEven"*).
          1. Let _roundingPriority_ be ? GetOption(_options_, *"roundingPriority"*, ~string~, ¬´ *"auto"*, *"morePrecision"*, *"lessPrecision"* ¬ª, *"auto"*).
          1. Let _hasFD_ be *true* if _mnfd_ is not *undefined* or _mxfd_ is not *undefined*; otherwise *false*.
          1. Let _hasSD_ be *true* if _mnsd_ is not *undefined* or _mxsd_ is not *undefined*; otherwise *false*.
          1. If _hasFD_ is *true*, then
            1. If _mnfd_ is *undefined*, set _mnfd_ to *+0*<sub>ùîΩ</sub>.
            1. Else if _mnfd_ is not an integral Number or ‚Ñù(_mnfd_) &lt; 0 or ‚Ñù(_mnfd_) > 20, throw a *RangeError* exception.
            1. If _mxfd_ is *undefined*, set _mxfd_ to ùîΩ(3).
            1. Else if _mxfd_ is not an integral Number or ‚Ñù(_mxfd_) &lt; 0 or ‚Ñù(_mxfd_) > 20, throw a *RangeError* exception.
            1. If ‚Ñù(_mnfd_) > ‚Ñù(_mxfd_), throw a *RangeError* exception.
          1. If _hasSD_ is *true*, then
            1. If _mnsd_ is *undefined*, set _mnsd_ to ùîΩ(1).
            1. Else if _mnsd_ is not an integral Number or ‚Ñù(_mnsd_) &lt; 1 or ‚Ñù(_mnsd_) > 21, throw a *RangeError* exception.
            1. If _mxsd_ is *undefined*, set _mxsd_ to ùîΩ(21).
            1. Else if _mxsd_ is not an integral Number or ‚Ñù(_mxsd_) &lt; 1 or ‚Ñù(_mxsd_) > 21, throw a *RangeError* exception.
            1. If ‚Ñù(_mnsd_) > ‚Ñù(_mxsd_), throw a *RangeError* exception.
          1. If _hasFD_ is *true* and _hasSD_ is *true* and _roundingPriority_ is *"auto"*, throw a *RangeError* exception.
          1. If _hasFD_ is *false* and _hasSD_ is *false*, then
            1. Set _mnfd_ to *+0*<sub>ùîΩ</sub>.
            1. Set _mxfd_ to ùîΩ(3).
          1. Return the Record { [[MinimumFractionDigits]]: _mnfd_, [[MaximumFractionDigits]]: _mxfd_, [[MinimumSignificantDigits]]: _mnsd_, [[MaximumSignificantDigits]]: _mxsd_, [[RoundingMode]]: _roundingMode_, [[RoundingPriority]]: _roundingPriority_ }.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-amount-applydigitoptions" type="abstract operation">
        <h1>ApplyDigitOptions (
          _value_: a Number,
          _opts_: a Record with fields [[MinimumFractionDigits]], [[MaximumFractionDigits]], [[MinimumSignificantDigits]], [[MaximumSignificantDigits]], [[RoundingMode]], and [[RoundingPriority]]
        ): a String
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It rounds _value_ according to the digit options in _opts_ and returns the result as a String.</dd>
        </dl>
        <emu-alg>
          1. Let _roundingMode_ be _opts_.[[RoundingMode]].
          1. Let _roundingPriority_ be _opts_.[[RoundingPriority]].
          1. Let _mnfd_ be _opts_.[[MinimumFractionDigits]].
          1. Let _mxfd_ be _opts_.[[MaximumFractionDigits]].
          1. Let _mnsd_ be _opts_.[[MinimumSignificantDigits]].
          1. Let _mxsd_ be _opts_.[[MaximumSignificantDigits]].
          1. If _value_ is *NaN*, return *"NaN"*.
          1. If _value_ is *+‚àû*<sub>ùîΩ</sub>, return *"Infinity"*.
          1. If _value_ is *-‚àû*<sub>ùîΩ</sub>, return *"-Infinity"*.
          1. Let _mv_ be ‚Ñù(_value_).
          1. If _value_ is *-0*<sub>ùîΩ</sub>, let _intlMV_ be ~negative-zero~; else let _intlMV_ be _mv_.
          1. If _mxsd_ is not *undefined* and _mxfd_ is not *undefined*, then
            1. Let _fdFractionDigits_ be ‚Ñù(_mxfd_).
            1. Let _sdFractionDigits_ be SignificantToFractionDigits(_intlMV_, ‚Ñù(_mxsd_)).
            1. If _roundingPriority_ is *"morePrecision"*, let _fractionDigits_ be max(_fdFractionDigits_, _sdFractionDigits_).
            1. Else, let _fractionDigits_ be min(_fdFractionDigits_, _sdFractionDigits_).
          1. Else if _mxsd_ is not *undefined*, then
            1. Let _fractionDigits_ be SignificantToFractionDigits(_intlMV_, ‚Ñù(_mxsd_)).
          1. Else,
            1. Assert: _mxfd_ is not *undefined*.
            1. Let _fractionDigits_ be ‚Ñù(_mxfd_).
          1. If _intlMV_ is a mathematical value, then
            1. Let _rounded_ be RoundAmountValueToFractionDigits(_intlMV_, _fractionDigits_, _roundingMode_).
          1. Else,
            1. Let _rounded_ be _intlMV_.
          1. If _fractionDigits_ &lt; 0, return RenderAmountValueWithFractionDigits(_rounded_, _fractionDigits_).
          1. If _rounded_ is a mathematical value and _rounded_ is not 0, then
            1. Let _actualDigits_ be the smallest non-negative integer _k_ such that _k_ ‚â§ _fractionDigits_ and abs(_rounded_) √ó 10<sup>_k_</sup> is an integer.
          1. Else,
            1. Let _actualDigits_ be 0.
          1. Let _displayDigits_ be _actualDigits_.
          1. If _mnfd_ is not *undefined* and ‚Ñù(_mnfd_) > _displayDigits_, set _displayDigits_ to ‚Ñù(_mnfd_).
          1. If _mnsd_ is not *undefined*, then
            1. Let _minFD_ be SignificantToFractionDigits(_rounded_, ‚Ñù(_mnsd_)).
            1. If _minFD_ > _displayDigits_, set _displayDigits_ to _minFD_.
          1. Return RenderAmountValueWithFractionDigits(_rounded_, _displayDigits_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-the-amount-constructor">
    <h1>The Amount Constructor</h1>
    <p>The Amount constructor:</p>
    <ul>
      <li>is <dfn>%Amount%</dfn>.</li>
      <li>is the initial value of the the *"Amount"* property of the global object.</li>
      <li>creates and initializes a new Amount object when called as a constructor</li>
      <li>may be used as the value of an *extends* clause of a class definition.</li>
    </ul>
    <emu-clause id="sec-the-amount-constructor-value">
      <h1>Amount ( _x_ [ , _opts_ ] )</h1>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. If _x_ is not a Number, not a BigInt, and not a String, throw a *TypeError* exception.
        1. If _x_ is a String, then
          1. Let _text_ be StringToCodePoints(_x_).
          1. Let _parsed_ be ParseText(_text_, |StringNumericLiteral|).
          1. If _parsed_ is a List of errors, throw a *RangeError* exception.
        1. Let _validatedOpts_ be ? GetAmountOptions(_opts_).
        1. Let _roundingMode_ be _validatedOpts_.[[RoundingMode]].
        1. Let _fractionDigits_ be _validatedOpts_.[[FractionDigits]].
        1. Let _significantDigits_ be _validatedOpts_.[[SignificantDigits]].
        1. Let _unit_ be _validatedOpts_.[[Unit]].
        1. Let _hasPrecision_ be *true* if _fractionDigits_ is not *undefined* or _significantDigits_ is not *undefined*; otherwise *false*.
        1. If _hasPrecision_ is *true*, then
          1. If _x_ is a String, then
            1. Let _intlMV_ be the StringIntlMV of _parsed_.
            1. Let _amountValue_ be _intlMV_[0].
          1. Else if _x_ is a BigInt, then
            1. Let _amountValue_ be ‚Ñù(_x_).
          1. Else,
            1. Assert: _x_ is a Number.
            1. If _x_ is *NaN*, let _amountValue_ be ~not-a-number~.
            1. Else if _x_ is *+‚àû*<sub>ùîΩ</sub>, let _amountValue_ be ~positive-infinity~.
            1. Else if _x_ is *-‚àû*<sub>ùîΩ</sub>, let _amountValue_ be ~negative-infinity~.
            1. Else if _x_ is *-0*<sub>ùîΩ</sub>, let _amountValue_ be ~negative-zero~.
            1. Else, let _amountValue_ be ‚Ñù(_x_).
          1. If _significantDigits_ is not *undefined*, set _fractionDigits_ to ùîΩ(SignificantToFractionDigits(_amountValue_, ‚Ñù(_significantDigits_))).
          1. If _amountValue_ is a mathematical value, then
            1. Set _amountValue_ to RoundAmountValueToFractionDigits(_amountValue_, ‚Ñù(_fractionDigits_), _roundingMode_).
          1. Let _value_ be RenderAmountValueWithFractionDigits(_amountValue_, ‚Ñù(_fractionDigits_)).
        1. Else,
          1. If _x_ is a Number or _x_ is a BigInt, then
            1. Let _value_ be _x_.
          1. Else,
            1. Assert: _x_ is a String.
            1. Let _intlMV_ be the StringIntlMV of _parsed_.
            1. Let _amountValue_ be _intlMV_[0].
            1. Let _numFractionDigits_ be CountFractionDigits of _parsed_.
            1. Let _value_ be RenderAmountValueWithFractionDigits(_amountValue_, _numFractionDigits_).
        1. Let _O_ be OrdinaryObjectCreate(%Amount.prototype%, ¬´ [[Value]], [[Unit]] ¬ª).
        1. Set _O_.[[Value]] to _value_.
        1. Set _O_.[[Unit]] to _unit_.
        1. Return _O_.
      </emu-alg>
      <emu-note>
        <p>When no precision options are given, Number and BigInt arguments are stored directly in [[Value]], preserving the original type. String arguments are normalized to StrDecimalLiteral form. When precision options are specified, [[Value]] always holds a String.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-amount-prototype-properties">
  <h1>Properties of the Amount Prototype</h1>

  <emu-clause id="sec-amount.prototype.value">
    <h1>get Amount.prototype.value</h1>
    <p>This accessor property, whose set accessor function is *undefined*, returns the numeric value of the Amount. Its get accessor function performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Value]]).
      1. Return _O_.[[Value]].
    </emu-alg>
    <emu-note>
      <p>The value may be a Number, BigInt, or String. It is a String when precision options were applied during construction or when the Amount is the result of unit conversion.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-amount.prototype.unit">
    <h1>get Amount.prototype.unit</h1>
    <p>This accessor property, whose set accessor function is *undefined*, returns a String value (or *undefined*) indicating the unit that this Amount has. Its get accessor function performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Value]]).
      1. Return _O_.[[Unit]].
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-amount.prototype.tostring">
    <h1>Amount.prototype.toString ( )</h1>
    <p>This method returns a String representation of the Amount, including a unit indicator in bracket notation.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Value]]).
      1. Let _v_ be _O_.[[Value]].
      1. Let _u_ be _O_.[[Unit]].
      1. If _v_ is a String, then
        1. Let _valueStr_ be _v_.
      1. Else if _v_ is a Number, then
        1. Let _valueStr_ be Number::toString(_v_, 10).
      1. Else,
        1. Assert: _v_ is a BigInt.
        1. Let _valueStr_ be BigInt::toString(_v_, 10).
      1. If _u_ is *undefined*, return the string-concatenation of _valueStr_ and *"[]"*.
      1. Return the string-concatenation of _valueStr_, *"["*, _u_, and *"]"*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-amount.prototype.tolocalestring">
    <h1>Amount.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
    <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Value]]).
      1. Return ? Call(%Amount.prototype.toString%, _O_, ¬´ ¬ª).
    </emu-alg>
    <p>The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
  </emu-clause>

  <emu-clause id="sec-amount.prototype.convertto">
    <h1>Amount.prototype.convertTo ( _options_ )</h1>
    <p>This method returns a new Amount whose value is the result of converting this Amount‚Äôs value from its current unit to a target unit. The target unit is specified by _options_.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Value]]).
      1. Let _sourceUnit_ be _O_.[[Unit]].
      1. If _sourceUnit_ is *undefined*, throw a *TypeError* exception.
      1. Let _processedOptions_ be ? GetOptionsObject(_options_).
      1. Let _targetUnit_ be ? GetOption(_processedOptions_, *"unit"*, ~string~, ~empty~, *undefined*).
      1. Let _locale_ be ? GetOption(_processedOptions_, *"locale"*, ~string~, ~empty~, *undefined*).
      1. Let _usage_ be ? GetOption(_processedOptions_, *"usage"*, ~string~, ~empty~, *undefined*).
      1. If _targetUnit_ is *undefined* and _locale_ is *undefined* and _usage_ is *undefined*, throw a *TypeError* exception.
      1. If _targetUnit_ is not *undefined*, then
        1. If _locale_ is not *undefined* or _usage_ is not *undefined*, throw a *TypeError* exception.
      1. Else,
        1. Throw a *TypeError* exception.
      1. Let _v_ be _O_.[[Value]].
      1. If _v_ is a Number, then
        1. Let _sourceValue_ be _v_.
      1. Else if _v_ is a BigInt, then
        1. Let _sourceValue_ be ùîΩ(‚Ñù(_v_)).
      1. Else,
        1. Assert: _v_ is a String.
        1. Let _sourceValue_ be StringToNumber(_v_).
      1. Let _convertedValue_ be ? ConvertUnitValue(_sourceValue_, _sourceUnit_, _targetUnit_).
      1. Let _digitOpts_ be ? GetConvertToDigitOptions(_processedOptions_).
      1. Let _resultStr_ be ApplyDigitOptions(_convertedValue_, _digitOpts_).
      1. Let _result_ be OrdinaryObjectCreate(%Amount.prototype%, ¬´ [[Value]], [[Unit]] ¬ª).
      1. Set _result_.[[Value]] to _resultStr_.
      1. Set _result_.[[Unit]] to _targetUnit_.
      1. Return _result_.
    </emu-alg>
    <emu-note>
      <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API supersedes this method to additionally support locale-based and usage-based unit conversion via CLDR unit preferences data. Without ECMA-402, only explicit unit-to-unit conversion (via the *"unit"* option) is supported.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-amount-symboltoprimitive">
    <h1>Amount.prototype [ %Symbol.toPrimitive% ] ( _hint_ )</h1>
    <p>This method is called by ECMAScript language operators to convert an Amount to a primitive value. The allowed values for _hint_ are *"default"*, *"number"*, and *"string"*.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[Value]]).
      1. If _hint_ is not in ¬´ *"default"*, *"number"*, *"string"* ¬ª, throw a *RangeError* exception.
      1. If _hint_ is *"string"*, return ? Call(%Amount.prototype.toString%, _O_, ¬´ ¬ª).
      1. Let _v_ be _O_.[[Value]].
      1. If _O_.[[Unit]] is not *undefined*, throw a *TypeError* exception.
      1. If _v_ is a Number, return _v_.
      1. If _v_ is a BigInt, return _v_.
      1. Assert: _v_ is a String.
      1. Return StringToNumber(_v_).
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-import href="./intl.emu"></emu-import>
